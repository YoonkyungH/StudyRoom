## Memory

### 메모리 계층
: 레지스터, 캐시, 메모리, 저장장치로 구성

<img width="445" alt="image" src="https://user-images.githubusercontent.com/57247474/176174445-9d42f669-8d4e-48ce-aaac-7a18e610b0ce.png">

> - **레지스터**  
> : CPU 안 작은 메모리로 휘발성이며 속도가 가장 빠르고 기억 용량이 가장 적다는 특징을 가지고 있다.
> - **캐시**  
> : L1, L2 캐시를 지칭하며 레지스터와 같은 특징을 가진다.
> - **주기억장치**  
> : RAM을 가리킨다. 휘발성이며 속도와 기억 용량은 보통이다.  
> (* RAM: 하드디스크로부터 일정량의 데이터를 복사해 임시 저장하고, 필요시 CPU에 빠르게 전달하는 역할 수행)
> - **보조기억장치**  
> : HDD, SDD를 가리키며, 휘발성이고 속도는 느리지만 기억 용량이 크다.

계층 구조를 가지는 이유는 경제성과 캐시 때문이다.

### 캐시
: cache, 데이터를 미리 복사해놓는 임시 저장소

빠른 장치와 느린 장치의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리이다.

실제로 메모리와 CPU 사이 속도 차이가 너무 커 레지스터 계층을 가운데 두어 속도 차이를 해결하는데 이렇게 계층 사이의 계층을 **캐싱 계층**이라고 한다.  
(캐시-보조기억장치 사이 주기억장치는 보조기억장치의 캐싱 계층)

자주 사용하는 데이터를 기반으로 캐시가 지정되는데 이는 **지역성**에 따라 결정된다.

> - **시간 지역성**  
> : temporal locality, 최근 사용 데이터에 다시 접근하려는 특성
> - **공간 지역성**  
> : spatial locality, 최근 접근한 데이터를 이루는 공간 또는 그 가까운 공간에 접근하는 특성

> - **캐시히트**  
> : 캐시에서 원하는 데이터를 찾음
> - **캐시미스**  
> : 캐시에서 찾지 못해 주 메모리에서 가져옴


### 가상 메모리
: virtual memory, 메모리 관리 기법 중 하나

컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것

이때 가상으로 주어진 주소를 가상 주소 logical address라고 하며, 실제 메모리상에 있는 주소를 실제 주소 physical address라고 한다.  
가상 주소는 메모리 관리장치(MMU)에 의해 실제 주소로 변환되며 이로 인해 사용자는 실제 주소를 의식할 필요 없이 프로그램을 구축할 수 있다.  

가상 메모리는 가상 주소와 실제 주소가 매핑되어 있으며 프로세스의 주소 정보가 들어 있는 페이지 테이블로 관리되며 이때의 속도 향상을 위해 TLB를 사용한다.  
> **TLB**  
> : 가상 메모리 주소를 물리적인 주소로 변환하는 속도를 높이기 위하여 사용되는 캐시  
>   
> 최근에 일어난 가상 메모리 주소와 물리 주소의 변환 테이블 저장  
> (일종의 주소 변환 캐시)

#### 스와핑
: swapping, 가상 메모리에는 존재하지만 실제 메모리인 RAM에는 현재 없는 데이터나 코드에 접근할 경우 페이지 폴드가 발생하는데 이를 방지하기 위해 당장 사용하지 않는 영역을 하드디스크로 옮겨 필요할 때 다시 RAM으로 불러와 올리고, 사용하지 않으면 다시 하드디스크로 내림을 반복해 RAM을 효과적으로 관리하는 것

#### 페이지 폴트
: page fault, 프로세스의 주소 공간에는 존재하지만 지금 이 컴퓨터의 RAM에는 없는 데이터에 접근했을 경우 발생  

이때 운영체제는 다음 과정으로 해당 데이터를 메모리로 가져와 마치 페이지 폴트가 전혀 일어나지 않은 것처럼 프로그램이 작동하도록 해준다.  
1. CPU는 물리 메모리를 확인해 해당 페이지가 없으면 트랩을 발생시켜 운영체제에 알림.  
2. 운영체제는 CPU의 동작을 멈춤.  
3. 운영체제는 페이지 테이블을 확인해 가상 메모리에 페이지가 존재하는지 확인하고, 없으면 프로세스를 중단하고 현재 물리 메모리에 비어 있는 프레임이 있는지 찾음. 물리 메모리에도 없다면 스와핑 발동.  
4. 비어있는 프레임에 해당 페이지를 로드하고, 페이지 테이블을 최신화.  
5. 중단되었던 CPU를 다시 시작.  

#### 스레싱
: thrashing, 메모리의 페이지 폴트율이 높은 것을 의미.  
이는 컴퓨터의 심각한 성능 저하를 초래.  

메모리에 너무 많은 프로세스가 동시에 올라가면 스와핑이 많이 일어나 발생하게 됨.  
페이지 폴트가 일어나면 CPU 이용률이 낮아지고, CPU 이용률이 낮아지면 운영체제는 CPU가 한가한줄 알고 가용성을 높이기 위해 더 많은 프로세스를 올림.  
=> 이런 악순환으로 스레싱이 발생.  

이를 해결하기 위해 메모리를 늘리거나 HDD를 SDD로 바꾸는 방법을 고려해볼 수 있음.  
이외로 운영체제에서 이를 해결할 수 있는 방법은 **작업세트와 PFF**가 있음.  

>  - **작업 세트**  
>: working set, 프로세스의 과거 사용 이력인 지역성을 통해 결정된 페이지 집합을 만들어 미리 메모리에 로드하는 것.  
>미리 메모리에 로드하면 탐색 비용을 줄일 수 있고, 스와핑 또한 줄이기 가능.  
>
>- **PFF**  
>: Page Fault Frequency, 페이지 폴트 빈도를 조절하는 방법.  
>상한선과 하한선을 만드는 방법.  
>(상한선에 도달한다면 페이지를 늘리고, 하한선에 도달한다면 페이지를 줄임)  


### 메모리 할당
- **연속 할당**  
	- 고정 분할 방식
	- 가변 분할 방식
- **불연속 할당**  
	- 페이징
	- 세그멘테이션
	- 페이지드 세그멘테이션

### 페이지 교체 알고리즘
- **FIFO** First In First Out
- **LRU** Least Recently Used
- **NUR** Not Used Recently
- **LFU** Least Frequently Used
