## 2020년 4회
### 1과목
> **XP(eXtreme Programming)**  
> : 수시로 발생하는 고객의 요구사항에 유연하게 대응하기 위해 고객의 참여와 개발 과정의 반복을 극대화하여 개발 생산성을 향상시키는 방법
>  
> **5가지 핵심 가치**  
> - 의사소통
> - 단순성
> - 용기
> - 피드백
> - 용기  
>   
> **의단용피존**  
>   
> **기본 원리**  
> - Pair Programming, 짝 프로그래밍  
> : 다른 사람과 함께 프로그래밍을 수행, 개발에 대한 책임을 공동으로
> - Test-Driven Development, 테스트 주도 개발  
> : 테스트 케이스를 먼저 작성해 무엇을 할건지에 대해 정확히 파악하고 자동화된 테스팅 도구를 사용  
> - Whole Team, 전체 팀  
> : 개발 구성원들은 모두 역할과 책임을 가짐  
> - Design Improvement, 디자인 개선 또는 Refactoring, 리팩토링  
> : 프로그램의 기능 변경 없이 단순화, 유연성 강화 등 시스템을 재구성  
> - Small Releases, 소규모 릴리즈  
> : 릴리즈 기간을 짧게해 고객의 요구에 대해 신속히 대응  
> - Continuous Integration, 계속적인 통합  
> : 모듈 단위로 나누어 개발된 코드들은 하나의 작업이 마무리 될 때마다 지속적으로 통합  
>   
> **짝테전디소계**  
>  
> **개발 프로세스 순서**  
> 1. 릴리즈 계획 수립  
> 2. 주기  
> 3. 승인 검사  
> 4. 소규모 릴리즈


> **럼바우 Rumbaugh 객체지향 분석 기법**  
> - 객체 모델링, Object Modeling  
> : 객체 다이어그램, 정보 모델링이라고도 하며 시스템에서 요구하는 객체를 찾고 객체들 간의 관계를 정의, 가장 중요하며 선행되어야 함  
> - 동적 모델링, Dynamic Modeling  
> : **상태** 다이어그램, 시간의 흐름에 따라 객체들 사이의 제어 흐름, 동작 순서 등의 동적인 행위를 표현  
> - 기능 모델링, Functional Modeling  
> : 자료 흐름도(DFD), 프로세스들의 자료 흐름을 중심으로 처리 과정 표현
>   
> **객체 모델링 -> 동적 모델링 -> 기능 모델링** (객동기)


> **표의 숫자 코드**  
> : 코드화 대상 항목의 중량, 면적, 용량 등의 물리적 수치를 이용해 만든 코드


> **DFD Data Flow Diagram**  
> : 시스템 구성 요소인 프로세스와 프로세스 간 데이터 흐름을 표현하는 주요 도구  
>   
> 자료 흐름 그래프 또는 Bubble 차트라고 부르기로 함  
> 구조적 분석 기법에 사용되며 자료 흐름과 기능을 자세히 표현하기 위해 단계적으로 세분화 함


> **UML 구성요소**
> - 관계
> - 사물
> - 다이어그램  
> (클래스 / 컴포넌트 / 배치 / 패키지 / 유스케이스 / 순차 다이어그램&통신 다이어그램 / 활동 / 상태)


> **소프트웨어 아키텍처**  
> : 소프트웨어를 구성하는 요소들 간의 관계를 표현하는 시스템의 구조 또는 구조체
> - **상위 설계**  
> 별칭: 아키텍처 설계, 예비 설계  
> 설계 대상: 시스템의 전체적인 구조  
> 세부 목록: 구조, DB, 인터페이스  
>   
> - **하위 설계**  
> 별칭: 모듈 설계, 상세 설계  
> 설계 대상: 시스템의 내부 구조 및 행위  
> 세부 목록: 컴포넌트, 자료구조, 알고리즘


> **자료 사전(DD, Data Dictionary)**  
> 자료 사전 기호  
> - `=`: 정의
> - `+`: 구성
> - `{}`: 반복
> - `[]`: 선택
> - `()`: 생략 가능
> - `**`: 주석


> **소프트웨어 사용자 인터페이스 개발 시스템(User Interface Development System) 기능**  
> - 사용자의 입력 검증
> - 에러 처리와 에러 메시지 처리
> - 도움과 prompt 제공


> **요구 사항 명세 기법**  
> : Requirement Specification
>   
> - **정형 명세 기법**
> 기법: 수학적 원리 기반, 모델 기반  
> 작성 기법: 수학적 기호, 정형화된 표기법  
> 특징  
> - 요구사항을 정확, 간결하게 표현 가능
> - 요구사항에 대한 결과가 작성자에 관계없이 일관성 있으므로 완전성 검증이 가능
> - 표기법이 어려워 사용자가 이해하기 어려움
> 종류: VDM, Z, Petri-net, CSP ...
>   
> - **비정형 명세 기법**  
> 기법: 상태/기능/객체 중심  
> 작성 기법: 일반 명사, 동사 등의 자연어를 기반으로 서술 또는 다이어그램으로 작성  
> 특징  
> - 자연어의 사용으로 요구사항에 대한 결과가 작성자에 따라 다를 수 있어 일관성이 떨어지며 해석이 달라질 수 있음
> - 내용의 이해가 쉬워 의사소통 용이
> 종류: FSM, Decision Table, ER 모델링, State Chart(SADT) ...


> **소프트웨어 개발 단계에서 요구 분석 과정**  
> - 분석 결과의 문서화를 통해 향후 유지보수에 유용하게 활용할 수 있음
> - 자료 흐름도, 자료 사전 등이 효과적으로 이용됨
> - 보다 구체적인 명세를 위해 소단위 명세서(Mini-Spec)이 활용


> **애자일 방법론**  
> : 좋은 것을 빠르게 취하고 낭비 없게 만드는 다양한 방법론을 통칭해 일컫는 말로,  
> 앞을 예측하며 개발하지 않고, 일정한 주기를 가지고 계속 검토해 나가며 필요할 때마다 요구사항을 더하고 수정하여 커다랗게 살을 붙이면서 개발함.  
> 미리 정해진 몇 단계에 따라 엄격한 순서대로 이루어지는 일직선의 과정인 **폭포수 프로스세스와 반대되는 개념**  
>   
> 계획 -> 설계(디자인) -> 개발(발전) -> 테스트 -> 검토(피드백)  
>  
> - 기능중심 개발
> - 스크럼(고객의 요구사항을 충족시키는데 초점을 맞춰 목표를 짧은 주기로 점진적이며 경험적으로 시스템을 지속해 개발하는 관리 프레임워크 기법)  
> [Scrum의 5가지 추구가치]: 용기, 집중, 확약, 존중, 정직   
> - 익스트림 프로그래밍


> **Gof(Gang of Four) 디자인 패턴**
> 목적에 따라 **생성, 구조, 행동**으로 나눌 수 있음
>  
> - **생성 패턴**
> : 객체의 인스턴스 과정을 추상화 하는 방법  
> 추상 팩토리, 빌더, 팩토리 메소드, 프로토타입, 싱글톤
>  
> - **구조 패턴**  
> : 클래스나 객체들을 조합해 더 큰 구조로 만들 수 있게 해주는 패턴  
> 어댑터, 브리지, 컴포지트, 데코레이터, 퍼싸드, 플라이웨이트, 프록시  
>   
> - **행위 패턴**  
> : 클래스나 객체들이 서로 상호작용하는 방법이나 어떤 태스트, 어떤 알고리즘을 어떤 객체에 할당하는 것이 좋을지 정의하는 패턴  
> 책임 연쇄, 커맨드, 인터프리터, 반복자, 중재자, 메멘토, 옵저버, 상태, 전략, 템플릿 메소드, 방문자


### 2과목
> **EAI(Enterprise Application Integration)**  
> : 기업 내 각종 애플리케이션 간의 상호연동이 가능하도록 통합하는 솔루션  
> 기업 정보 시스템들의 데이터를 연계/통합하는 소프트웨어 및 정보시스템 아키텍처 프레임워크  
>   
> **[데이터 연계 방식]**  
> - 기존의 데이터 연계 방식: Point to Point
> : 연결 양끝 노드 간 일대일 직렬 링크를 구성해 데이터 연계, 연결은 N(N-1)/2개 발생
>   
> - EAI 데이터 연계 방식: Hub and Spoke  
> : 허브가 연결 대상 노드들의 데이터 연계 요구를 중계하여 노드 간 연결 개수 및 구조를 단순화하는 방식  
>   
> **[EAI 구현 유형]**  
> - Mediation(intra-communication)  
> : 특정 정보 시스템 내 데이터 신규 생성 및 갱신, 신규 트랜잭션 완료 등 이벤트 발생을 식별해 미리 약속된 정보 시스템에 해당 내용을 전달  
>   
> - Federation(inter-communication)  
> : EAI 엔진이 외부 정보 시스템으로부터 데이터 요청들을 일괄적으로 수령해 필요한 데이터를 전달 


> **알파 검사**  
> : 검증검사 기법 중 개발자의 장소에서 사용자가 개발자 앞에서 행해지며, 오류와 사용상의 문제점을 사용자와 개발자가 함게 확인하며 검사하는 기법


> **삽입 정렬 insert sort**  
> : 자료 배열의 모든 요소를 앞에서부터 차례대로 이미 정렬된 배열 부분과 비교해 자신의 위치를 찾아 삽입해 정렬 


> **인터페이스 구현 검증 도구**  
> - xUnit
> - STAF
> - FitNesse
> - NTAF
> - Selenium
> - watir


> **소프트웨어 형상 관리 SCM: Software Configuration Management**  
> : 각 개발 단계의 산출물을 관리하는 모든 활동  
>   
> **[형상 항목]**  
> - 시스템 명세서
> - 소프트웨어 프로젝트 계획서
> - 소프트웨어 요구사항 명세서
> - 예비 사용자 메뉴얼
> - 설계 문서
> - 원시 모드 목록
> - 시험 계획 및 절차
> - 시험 사례 및 기록 결과
> - 운영과 설치 메뉴얼
> - 실행 가능한 프로그램 etc


> **내부 스키마**  
> : 물리적 저장 장치의 입장에서 본 데이터베이스 구조로써 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서등을 나타냄


> **중위 순회 Inorder Traversal**  
> 왼쪽 노드의 **왼쪽 자식 노드** -> **왼쪽** 노드 -> 왼쪽 노드의 **오른쪽 자식 노드** -> **부모** 노드 -> 오른쪽 노드의 **왼쪽 자식 노드** -> **오른쪽** 노드 -> 오른쪽 노드의 **오른쪽 자식 노드**  


> 정점이 N개인 무방향 그래프에서 최대 간선 수: `N(N-1)/2`  
> 정점이 N개인 그래프의 최대 간선 수: `N(N-1)`


> **테스트 오라클**  
> - 테스트의 결과가 참인지 거짓인지 판단하기 위해 사전에 정의된 참값을 입력해 비교하는 기법 및 활동  
> - 종류에는 참, 샘플링, 휴리스틱, 일관성 검사가 존재


> **빌드 자동화 도구**  
> - Gradle은 실행할 처리 명령들을 모아 테스크로 만든 후 테스크 단위로 실행
> - 빌드 자동화 도구는 지속적인 통합개발환경에서 유용하게 활용
> - 빌드 자동화 도구에는 Ant, Gradle, Jenkins등이 있음


> **디지털 저작권 관리 DRM: Digital Right Management)**  
> - 클리어링 하우스  
> : 저작권에 대한 사용 권한, 라이센스 발급, 사용량에 따른 결제 관리 수행
> - 컨텐츠 제공자  
> : 컨텐츠를 제공하는 저작권자  
> - 패키저  
> : 컨텐츠를 메타데이터와 함께 배포 가능한 형태로 묶어 암호화하는 프로그램  
> - 컨텐츠 분배자  
> : 암호화된 컨텐츠를 유통하는 곳이나 사람  
> - 컨텐츠 소비자  
> : 컨텐츠를 구매해 사용하는 주체
> - DRM 컨트롤러  
> : 배포된 컨텐츠의 이용 권한을 통제하는 프로그램  
> - 보안 컨테이너  
> : 컨텐츠 원본을 안전하게 유통하기 위한 전자적 보안 장치  
>   
> **[디지털 저작권 관리의 기술 요소]**  
> - 암호화
> - 키 관리
> - 암호화 파일 생성
> - 식별 기술
> - 저작권 표현
> - 정책 관리
> - 크랙 방지
> - 인증


> **블랙박스 테스트**  
> : 소프트웨어 내부 구조나 작동 원리를 모르는 상태에서 소프트웨어 동작을 검사하는 방법  
> - 동등 분할 기법
> - 경계값 분석 기법
> - 오류 예측 기법
> - 원인 결과 그래프 기법
> - 의사결정 테이블 테스팅
> - 상태전이 테스팅
>   
> **화이트박스 테스트**  
> : 소프트웨어 혹은 제품의 내부 구조, 동작을 세밀하게 검사하는 테스트 방식, 외부에서 요구사항에 따른 예상 결과값을 테스트하는 것과 다르게 내부 소스 코드를 테스트하는 기법으로 사용자가 들여다볼 수 없는 구간의 코드 단위를 테스트함  
> - 문장 검증
> - 분기 검증
> - 경로 검증
> - 조건 검증


> **폴딩법**  
> : 해싱함수 중 레코드 키를 여러 부분으로 나누고 나눈 부분의 각 숫자를 더하거나 XOR한 값을 홈 주소로 사용하는 방식


### 3과목
> 트랜잭션: 데이터베이스의 상태를 변경시키기 위해 수행하는 작업 단위  
>   
> **트랜잭션 특징**  
> - 원자성: DB에 모두 반영되거나, 전혀 반영되지 않거나
> - 일관성: 작업 처리의 결과가 항상 일관되어야 함
> - 독립성: 하나의 트랜잭션은 다른 트랜잭션에 끼어들 수 없고 마찬가지로 독립적임
> - 지속성: 트랜잭션이 성공적으로 완료되면 영구적으로 결과에 반영되어야 함


> **CRUD 분석**  
> : 데이터베이스에 영향을 주는 생성, 읽기, 갱신, 삭제 연산으로 프로세스와 테이블 간 매트릭스를 만들어서 트랜잭션을 분석하는 것


> **반정규화**  
> : 정규화된 엔티티, 속성, 관계를 시스템의 성능 향상과 개발 운영의 단순화를 위해 중복, 통합, 분리 등을 수행하는 데이터 모델링 기법


> **E-R 다이어그램**  
> : 존재하고 있는 것들의 관계를 나타낸 도표  
> <img width="423" alt="image" src="https://user-images.githubusercontent.com/57247474/178654980-70e75719-af74-4a3a-af91-e6392edfaf5a.png">


> 릴레이션에 있는 모든 튜플에 대해 **유일성은 만족시키지만 최소성은 만족시키지 못하는 키** => **슈퍼키**


> **GRANT**: 권한부여  
> **Revoke**: 권한회수 


> **관계 대수 relational algebra**  
> - 주어진 릴레이션 조작을 위한 연산 집합
> - 일반 집합 연산과 순수 관계 연산으로 구분
> - 질의에 대한 해를 구하기 위해 수행해야 할 연산의 순서를 명시


>  **로킹 Locking**  
>  : 로킹 기법이란 하나의 트랜잭션이 데이터를 액세스하는 동안 다른 트랜잭션이 그 데이터 항목을 액세스할 수 없도록 하는 병행 제어 기법  
>  한 번에 한 명만 사용할 수 있게 하는 단위 -> **로킹 단위**
>  
> 로킹 단위가 **커지면 병행성 감소**, 로킹 단위가 **작아지면 병행성 증가**  
>  
> 데이터베이스도 로킹 단위가 될 수 있으며 로킹 단위가 커지면 로크 수가 작아 로킹 오버헤드가 감소한다.


> 데이터베이스의 **View**  
> : 한 개 이상의 기본 테이블이나 다른 뷰를 이용하여 생성되는 가상 테이블(virtual table)  
>   
> - 뷰 위에 또 다른 뷰를 정의할 수 있음
> - 뷰에 대한 조작에서 삽입, 갱신, 삭제 연산은 제약이 따름
> - 뷰가 정의된 기본 테이블이 제거되면 뷰도 자동적으로 제거


> **데이터 모델**  
> 구성요소: 개체, 속성, 관계  
> 종류: 개념적 데이터 모델, 논리적 데이터 모델, 물리적 데이터 모델  
> 표기 요소: 구조, 연산, 제약조건


> **정규형**  
> - 제1 정규형(1NF)  
> : 릴레이션에 속하는 속성의 속성 값이 모두 **원자값(Atomic Value)** 로 구성  
>   
> - 제2 정규형(2NF)  
> : 제1 정규형이면서, **기본키(primary key)에 속하지 않은 속성 모두가 기본키에 완전 함수 종속**  
>   
> - 제3 정규형(3NF)  
> : 제2 정규형이면서, **이행적 함수 종속성을 제거**한 정규형  
> 즉, 학번|지도교수|학과 -> 학번|지도교수, 지도교수|학과  
>   
> - BCNF(Boyce and Codd Normal Form)  
> : 제3 정규형을 조금 더 강화시킨 개념으로 **릴레이션 R의 모든 결정자(determinant)가 후보키**면 그 릴레이션 R은 어떤 정규형 => 보이스/코드  


> **[데이터베이스 용어]**  
> - **릴레이션 Relation**  
> : DB 테이블  
>   
> - 한 릴레이션에는 똑같은 튜플이 포함될 수 없어 **릴레이션에 포함된 튜플은 모두 상이**  
> - 튜플 사이에는 순서가 없음  
> - 튜플의 삽입, 삭제 등의 작업으로 인해 릴레이션은 시간에 따라 변함  
> - 릴레이션을 구성하는 튜플을 유일하게 식별하기 위해 속성들의 부분집합 키(key)로 설정
> - 속성의 값은 논리적으로 더 이상 쪼갤 수 없는 원자 값만을 저장
>   
> - **속성 Attribute**  
> : 내가 저장하고 싶은 개체 항목  
> Ex. 이름, 나이, 주소 ... 와 같은  
>  
> - **차수 Degree**  
> : 한 릴레이션 안에 있는 애트리뷰트(속성) 수  
> 이름, 나이, 주소 속성을 가진 릴레이션의 경우 차수는 `3`
>   
> 릴레이션은 적어도 하나 이상의 애트리뷰트를 가져야한다.  
>   
> - **튜플 Tuple**  
> : 릴레이션의 각 행을 레코드라고 하는데 이가 튜플이다.  
> 데이터가 4개 있으면 튜플의 수는 4개  
>   
> - **카디널리티 Cardinality**  
> : 릴레이션 튜플의 개수  
> 차수와 다르게 카디널리티는 0이 될 수 있다. (데이터 삽입 전)  
>   
> - **도메인 Domain**  
> : 릴레이션에 포함된 속성들이 각각 가질 수 있는 값들의 집합  
> 예를 들어 결혼 여부라는 속성은 기혼, 미혼으로 나뉠 수 있고 이는 하나의 도메인 안에 들어간다. 그리고 해당 속성은 이 도메인 안에 있는 값만을 가질 수 있다.  
>   
> - **스키마 Schema**  
> : 데이터베이스 구조와 제약 조건에 관한 전반적인 명세를 기술한 메타데이터 집합  
> Entity(개체), Attribute(속성), Relationship(관계) 및 데이터 조작 시 데이터 값들이 갖는 제약 조건에 대해 전반적으로 정의함
>  
> **[논리 모델 vs 물리 모델]**  
> 


> **데이터베이스 설계**  
> - 개념적 설계
> - 논리적 설계
> - 물리적 설계  
> [물리적 설계에서 수행되는 작업]  
> - 저장 레코드 양식 설계
> - 접근 경로 설계
> - 레코드 집중 분석 및 설계
> - 파일의 저장 구조 및 탐색 기법


> **OLAP(online analytical processing)**  
> [OLAP 연산]  
> - Roll-up
> - Drill-down
> - Pivoting
> - Slicing
> - Dicing


### 4과목
> Unix shell 에서 환경 변수 출력  
> : `printenv`, `env`, `setenv`


> **페이지 교체 알고리즘**  
> - **FIFO (First In Forst Out)**  
> : 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 알고리즘


> **Stop and Wait 기법**  
> : TCP 흐름제어기법 중 프레임이 손실되었을 때, 손실된 프레임 1개를 전송하고 수신자의 응답을 기다리는 방식으로 한 번에 프레임 한 개만 전송할 수 있는 기법


> **결합도 Coupling**  
> 내용 > 공통 > 외부 > 제어 > 스탬프 > 자료  
>   
> - **내용 결합도**(Content coupling)  
> : 다른 모듈 내부에 있는 변수나 기능을 다른 모듈에서 사용하는 경우의 결합도  
>   
> - **공통 결합도**(Common coupling)  
> : 파라미터가 아닌 모듈 밖에 선언되어 있는 전역 변수를 참조하고 전역 변수를 갱신하는 식으로 상호작용하는 경우의 결합도  
>   
> - **외부 결합도**(Extenal coupling)  
> : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 결합도  
>   
> - **제어 결합도**(Control coupling)  
> : 어떤 모듈이 다른 모듈의 내부 논리 조직을 제어하기 위한 목적으로 제어 신호를 이용해 통신하는 경우의 결합도.  
> 하위 모듈에서 상위 모듈로 제어 신호가 이동해 상위 모듈에게 처리 명령을 부여하는 권리 전도 현상이 발생하는 결합도  
>   
> - **스탬프 결합도**(stamp coupling)  
> : 모듈 간의 인터페이스로 배열이나, 객체, 구조 등이 전달되는 경우의 결합도  
>   
> - **자료 결합도**(Data coupling)  
> : 모듈 간의 인터페이스로 전달되는 파라미터를 통해서만 모듈 간의 상호작용이 일어나는 경우의 결합도


> **응집도**  
> 우연적 < 논리적 < 시간적 < 절차적 < 통신적 < 순차적 < 기능적  
>   
> - **우연적 응집도**(Coincidental Cohesion)  
> : 서로 간에 어떠한 의미 있는 연관 관례도 없는 기능 요소로 구성될 경우의 응집도  
>   
> - **논리적 응집도**(Logical Cohesion)  
> : 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들이 한 모듈에서 처리되는 경우의 응집도  
>   
> - **시간적 응집도**(Temporal Cohesion)  
> : 연관된 기능이라기 보다는 특정 시간에 처리되어야 하는 활동들을 한 모듈에서 처리할 경우의 응집도  
>   
> - **절차적 응집도**(Procedural Cohesion)  
> : 모듈이 다수의 관련 기능을 가질 때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우의 응집도  
>   
> - **통신적 응집도**(Communication Cohesion)  
> : 동일한 입력과 출력을 사용해 다른 기능을 수행하는 활동들이 모여 있을 경우의 응집도  
>   
> - **순차적 응집도**(Sequential Cohesion)  
> : 모듈 내에서 한 활동으로부터 나온 출력 값을 다른 활동이 사용할 경우의 응집도  
>   
> - **기능적 응집도**(Functional Cohesion)  
> : 모듈 내부의 모든 기능이 단일한 목적을 위해 수행되는 경우의 응집도  

### 5과목
> **VPN**  
> : 이용자가 인터넷과 같은 공중망에 사설망을 구축해 마치 전용망을 사용하는 효과를 가지는 보안 솔루션


> **CMM(Capability Maturity Model)**  
> : 소프트웨어 관리/공학/지원 프로세스의 신뢰적이고 일관성 있는 능력평가 기반 구조  
>   
> [5가지 성숙 단계와 평가 기준]  
> 1. 초기단계  
> 2. 반복단계  
> 3. 정의단계  
> 4. 관리단계  
> 5. 최적화 단계  


> **폭포수 모델**  
> : 순차적인 소프트웨어 개발 프로세스  
>  
> - 가장 오래된 모형으로 많은 적용 사례가 있지만 요구사항의 변경이 어려우며, 각 단계의 결과가 확인되어야지만 다음 단계로 넘어간다. 선형 순차적 모형으로 고전적 생명 주기 모형이라고도 한다.  
> <img width="352" alt="image" src="https://user-images.githubusercontent.com/57247474/178882584-d40ea4db-8b12-40d6-9341-a592de3256c4.png">



> 서비스 지향 아키텍처 기반 애플리케이션 구성 층  
> - 표현층
> - 프로세스층
> - 비즈니스층


> **스토리지 시스템 Storage System)**  
> - **SAN (Storage Area Network)**  
> : 특수 목적용 고속 네트워크  
> 각 서버와 스토리지 사이 광 스위치를 넣어 네트워크 개념을 도입한 것으로 빠른 전송 속도, 안정적 시스템, 원거리 분산된 저장장치 사이 대용량 데이터를 업/다운로드 가능하다.  
> 하지만, 구축 비용이 비싸며 구조가 복잡하다.  
>   
> - **NAS (Network Attached Storage) Network 부착 저장소**  
> : 대용량 데이터의 파일을 공유하기 위해 발전된 스토리지  
> 하드웨어적인 파일 서버 기능뿐만 아니라 소프트웨어적인 부분도 내장된 다양한 애플리케이션을 사용해 파일을 공유할 수 있게 되었고, 장소에 구애받지 않고 접속 가능하다.  
> 하지만, 사용자가 많아지거나 I/O가 많아지면 성능저하가 DAS, SAN에 비해 심하다.
>   
> - **DAS (Direct Attached Storage) Direct 부착 저장소**  
> : 서버와 전용 케이블로 연결된 외장형 저장장치를 의미  
> (가정용 PC에 연결된 외장하드가 대표적임)  
> 전용 선을 이용하기에 성능을 보장하고 안정성이 뛰어나는 반면, 파일 공유가 불가능하고 확장 및 유연성이 떨어진다.  


> **SADT**  
> : SoftTech사에서 개발된 것으로 구조적 요구 분석을 하기 위해 블록 다이어그램을 채택한 자동화 도구  


> **접근 통제 정책 Access Control Policy**  
> <img width="210" alt="image" src="https://user-images.githubusercontent.com/57247474/178884342-d3aa8e3a-fad4-498a-beeb-284055cf3c00.png">


> **소프트웨어 개발 모델 중 나선형 모델의 4가지 주요 활동**  
> (나선형 모델: 뺑뺑이 모델)  
>   
> 1. 목표 설정  
> 2. 위험 분석  
> 3. 구현 및 테스트  
> 4. 고객평가 및 다음 단계 수립  


> **소프트웨어 비용 추정 모형**  
> - **COCOMO**  
> : 보헴이 제안한 모형, 프로그램 규모에 따라 비용을 산정  
> **Organic**(5만 라인 이하), **Semi-Detached**(30만 라인 이하), **Embedded**(그 이상)  
>   
> - **Putnam**  
> : 소프트웨어 개발 주기간 단계별로 요구할 인력의 분포를 가정하는 모형  
>   
> - **FP**  
> - **PERT**  
> - **WBS**  
> - **CPM**  
> - **간트(Gantt) 차트**  


> **공개키 암호화 방식**  
> : 암호화 복호화에 이용하는 키가 다른 방식  
> 공개 키 암호를 구성하는 알고리즘은 대칭 키 암호 방식과 비교해 **비대칭 암호**라고 부르기도 한다.  
>   
> 키를 만드는 사람은 **공개키를 일반에 공개하고, 특정한 비밀 키는 자신만** 알 수 있도록 숨긴다. 그래서 누가 암호화하던 **키를 만든 사람만이 메시지를 복호화**할 수 있다.
>  
> 대표적인 기법으로 RSA 기법이 있다.  
> 키 분배가 용이하고, 관리해야 할 키 개수가 적다.


> **전송 방식의 다중화 기술**  
> - 주파수분할 다중화(**FDM**, Frequency Devision Multiplexing)  
> - 시간분할 다중화(**TDM**, Time Division Multiplexing)  
> - 코드분할 다중화(**CDM**, Code Division Multiplexing)  
> - 파장분할 다중화(**WDM**, Wavelength Division Multiplexing)  
> : 파장이 서로 다른 복수의 광신호를 동시에 이용하는 것으로 광섬유를 다중화 하는 방식. 빛의 파장 축과 파장이 다른 광선은 서로 간섭을 일으키지 않는 성질을 이용함. 


> **CBD(Component Based Development)**  
> : 재사용 가능한 컴포넌트의 개발 또는 상용 컴포넌트들을 조합해 어플리케이션 개발 생산성, 품질을 높이고, 시스템 유지보수 비용을 최소화 할 수 있는 혁신 개발방법론
>   
> - 개발 기간 단축으로 인한 생산성 향상
> - 새로운 기능 추가가 쉬운 확장성  
> - 소프트웨어 재사용 가능  


> **SDDC(Software Defined Data Center), 소프트웨어 정의 데이터센터**  
> - 컴퓨팅, 네트워킹, 스토리지, 관리 등을 모두 소프트웨어로 정의
> - 인력 개입 없이 소프트웨어 조작만으로 자동 제어 관리
> - 데이터센터 내 모든 자원을 가상화하여 서비스


> **Secure OS**  
> : 컴퓨터 운영체제의 커널에 보안 기능을 추가한 것으로 운영체제의 보안상 결함으로 인해 발생 가능한 각종 해킹으로부터 시스템을 보호하기 위해 사용되는 것


> **NS chart(Nassi-Shneiderman diagram)**  
> : 프로그램 처리 흐름을 상자 형태의 그림으로 나타낸 그림  
>   
> - 논리의 기술에 중점을 둔 도형식 표현 방법
> - 연속, 선택 및 다중 선택, 반복 등의 제어논리 구조로 표현
> - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합


> **MapReduce**  
> - 대용량 데이터를 분산 처리하기 위한 목적으로 개발된 프로그래밍 모델
> - 구글에 의해 고안된 기술로써 대표적인 대용량 데이터 처리를 위한 병렬 처리기법 제공
> - 임의의 순서로 정렬된 데이터를 분산 처리하고 이를 다시 합치는 과정을 거침


> **SPICE**  
> : 소프트웨어 프로세스에 대한 개선 및 능력 측정 기준에 대한 국제 표준
