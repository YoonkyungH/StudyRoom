## 10가지 디자인 패턴

### 1. 싱글톤 패턴
: singleton pattern, **하나의 클래스에 오직 한 인스턴스만**을 가지는 패턴

하나의 인스턴스를 다른 모듈들이 공유하여 인스턴스 생성 비용을 절감할 수 있지만, 의존성이 높아질 수 있다.

데이터베이스 연결 인스턴스 생성 비용을 아낄 수 있어 데이터베이스 연결 모듈이 많이 사용된다.

하지만 **TDD**(Test Driven Development, 테스트 주도 개발)를 할 때 걸림돌이 된다.
TDD는 주로 단위 테스트인데 이것은 서로 독립적이어야 하며 테스트를 어떤 순서로든 실행시킬 수 있어야 한다.

그러나 싱글톤 패턴은 미리 생성된 하나의 인스턴스를 기반으로 구현하는 패턴이기 때문에 각 테스트별 독립적인 인스턴스를 만들기 어렵다.

또한, 싱글톤 패턴은 의존성을 높일 위험이 있다.
이는 **DI**(Dependency Injection, 의존성 주입)을 통해 모듈간 결합을 조금 느슨하게 만들어 해결할 수 있다.

의존성 주입을 통해 어플리케이션 의존성 방향이 일관되고, 쉽게 추론할 수 있으며, 모듈 간 관계가 더 명확해질 수 있다.

### 2. 팩토리 패턴
: factory pattern, 객체를 사용하는 코드에서 객체 생성 부분을 떼어내 추상화한 패턴

상속 관계에 있는 두 클래스에서 상위 클래서가 중요한 뼈대를 결정, 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴이다.

많은 유연성을 가지며 리팩토링 시 유지 보수성이 증가된다.

### 3. 전략 패턴
: strategy pattern 또는 policy pattern, 객체의 행위를 변경할 때 전략이라고 부르는 캡슐화 한 알고리즘을 컨텍스트 안에서 바꿔주며 상호교체가 가능하도록 만드는 패턴

### 4. 옵저버 패턴
: observer pattern, 옵저버에게 상태 변화를 알려주는 패턴

> **옵저버 observer**
> : 관측자 혹은 감시자

주체가 어떤 객체의 상태 변화를 관찰하며 메소드 등을 통해 옵저버 목록에 있는 옵저버들에게 상태 변화를 알려주는 패턴이다.

옵저버 패턴은 MVC(Model-View-Controller) 패턴에도 사용된다.

모델(주체)에 변경 사항이 생기면 `update()` 메소드로 뷰(옵저버)에게 알려주고 이를 기반으로 컨트롤러가 작동한다.

### 5. 프록시 패턴
: proxy pattern, 대상 객체에 접근하기 전 그 접근 흐름을 가로채 앞단 인터페이스 역할을 하는 디자인 패턴

> **프록시 서버 proxy server** 
> : 서버-클라이언트 사이 클라이언트가 자신을 통해 다른 네트워크 서비스에 간접적으로 접속할 수 있도록 해주는 응용 프로그램 

CORS(Cross-Origin Resource Sharing) 에러를 마주쳤을 때 프록시 서버를 두면 된다.
(해당 에러는 프론트엔드 서버와 백엔드 서버의 포트 번호가 다르기 때문에 발생하는 것)

### 6. 이터레이터 패턴
: iterator pattern, 이터레이터를 사용해 컬렉션 요소들에 접근하는 디자인 패턴

### 7. 노출 패턴
: revealing module pattern, 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴 

### 8. MVC 패턴
: Model-View-Controller로 이루어진 디자인 패턴

> **Model**
> : 어플리케이션 데이터인 데이터베이스, 상수, 변수 등을 뜻함  
> **View**
> : 사용자 인터페이스 요소  
> **Controller**
> : 하나 이상의 모델과 하나 이상의 뷰를 이어주는 다리 역할 

### 9. MVP 패턴
: Model-View-Presenter

뷰와 프레젠터는 1:1 관계로 MVC 패턴보다 더 강한 결합을 가진다.

### 10. MVVM 패턴
: Model-View-View Model

> View Model - 뷰를 더 추상화 한 계층 
