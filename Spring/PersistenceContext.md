## JPA에서 가장 중요한 두 가지
- 객체와 관계형 데이터베이스 매핑
- **영속성 컨텍스트**

## 영속성 컨텍스트
: 엔티티를 영구 저장하는 환경  
DB로 가기 전 가상 공간으로 눈에 보이지 않는 논리적 개념이다.

영속성 컨텍스트에 접근하기 위해서는 **EntityManager**를 통해야 한다.

*J2SE 환경에서 엔티티 매니저와 영속성 컨텍스트는 1:1 관계이다.  
엔티티 매니저 속에 영속성 컨텍스트라는 가상 공간이 생성된다고 이해하면 될 것 같다.

> * J2SE  
> : 일반 자바 프로그램 개발을 위한 용도로 사용되는 개발 도구

### 엔티티 생명주기
- **비영속**  
: new/transient, 영속성 컨텍스트와 전혀 관계없는 **새로운 상태**

- **영속**  
: managed, 영속성 컨텍스트에 의해 **관리되는 상태**

- **준영속**  
: detached, 영속성 컨텍스트에 저장되었다 **분리된 상태**

- **삭제**  
: removed, **삭제된 상태**

**비영속** 상태란 딱 객체를 선언해 생성한 그 상태를 이른다.  
(EntityManager.persist() 이전)

**영속** 상태란 생성한 객체를 저장한 상태를 이른다.
(EntityManager.persist()한 상태)  
이 상태 또한 **DB에 저장되지 않은 상태**이다.

**준영속** 상태란 EntityManager.detach()를 통해 영속성 컨텍스트에서 분리한 상태를 이른다.  
**삭제** 상태는 말 그대로 EntityManager.remove()로 객체를 삭제한 상태이다.

### 영속성 컨텍스트의 이점
- 1차 캐시
- 동일성(identity) 보장
- 트랜잭션을 지원하는 쓰기 지연
- 변경 감지(Dirty Checking)
- 지연 로딩(Lazy Loading)

1차 캐시란 영속성 컨텍스트 내부에 1차 캐시가 존재하는데 persist()될 때 우선 **1차 캐시에 저장**되기 때문에 find()하면 DB까지 찾으러 가지 않고도 1차 캐시에서 결과를 얻을 수 있다.  
(1차 캐시에서 그치기 때문에 DB query가 날라가지 않는다.)

만약 1차 캐시에 원하는 것이 없다면 **DB 조회 후 1차 캐시에 저장**한다.

그리고 persist()할 때 바로 DB에 저장되는 것이 아니라고 했다.  
커밋하는 순간 즉, EntityTransaction.commit()을 수행할 때 데이터베이스에 INSERT sql을 보내 저장된다.

persist()를 하면 **쓰기 지연 SQL 저장소**에 담아둔다.  
그리고 커밋하는 순간 DB에 쿼리를 날려 저장한다.

변경 감지는 커밋하게 되면 내부에서 **플러시**가 발생하고 엔티티와 스냅샷을 비교한다.  
스냅샷과 비교해 바뀌었다면 UPDATE SQL을 생성해 DB에 전송한다.

### 플러시
: flush, 영속성 컨텍스트의 변경내용을 데이터베이스에 반영하는 것

위에서 언급했듯 플러시가 발생하면 **변경 감지**가 발생하고 **수정된 엔티티 쓰기 지연 SQL 저장소에 등록**된다.  
그리고 쓰기 지연 SQL 저장소의 **쿼리를 데이터베이스에 전송**한다.

플러시 되려면 EntityManager.flush()로 직접 호출하거나 트랜잭션 커밋 또는 JPQL 쿼리가 실행되면 플러시가 자동 호출된다.
