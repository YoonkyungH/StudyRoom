# ⭐️ 다익스트라 알고리즘 ⭐️
: Dijkstra Algorithm   

다익스트라 알고리즘은 **음이 아닌 가중치 그래프**에서 단일 쌍, 단일 출발, 단일 도착 최단 경로 문제를 해결할 수 있다.   

### 원리
다익스트라는 **시작 노드부터 각 노드까지의 거리를 저장하는 배열**을 이용해 탐색하며 `현재 누적 최단 거리 + 간선 가중치`가 `이동하는 노드까지의 저장된 최단 거리`보다 **작으면 업데이트** 시킨다.   

➡️ ***현재 누적 최단 거리 + 간선 가중치의 합  < 이동하는 노드까지의 저장된 최단 거리***   

그리고 **Priority_queue**를 이용해 업데이트 된 값을 저장해 늘 최단거리가 짧은 순서부터 탐색하도록 하여 **시간 복잡도를 줄일 수 있다.**   

방문 여부 배열(Ex. visited[])로 이미 방문된 노드를 패스한다.   
`모든 노드를 방문했거나`, `방문하지 않은 노드를 방문할 수 없거나`, `priority_queue가 비워지면` **while문을 종료**한다.   

> ### MST vs 다익스트라
- `MST`: Minimum Spanning Tree, 최소 신장 트리   
**최소 weight로 모든 노드를 연결하는 것**   

- `다익스트라`: Dijkstra
***정해진 어떤 노드에서* 모든 노드까지의 최소 경로를 구하는 것**   

> ### 벨만-포드 vs 다익스트라
- `벨만-포드`: Bellman-Ford   
**음의 순환이 없는 경우 출발 노드로부터 다른 노드까지의 최단 거리를 산출**한다.   
그리고 **음의 순환 여부 확인**이 가능하지만 비교적 **오래 걸린다**는 단점이 있다.   

- `다익스트라`: 모든 간선이 **양수**이며   
***사실상 최단 거리 문제는 다익스트라 알고리즘으로 푼다고 생각***하면 된다.   

> ### 플로이드워셜 vs 다익스트라
- `플로이드워셜`: Floyd-Warshall   
모두 때려박아 계산하기 때문에 **임의의 두 간선에 대한 최단 경로**를 구할 수 있다.   

  그리고 수행 시간은 `O(N^3)`으로 오래걸리는 편이다.   
**N^3**인 이유는 **3중 for문**을 이용하기 때문이다.   
그래서 수행 시간 측면에서 노드의 개수가 제한적이다.   

- `다익스트라`: **출발 노드가 정해진 상태에서 다른 모든 노드로의 최단 거리를 산출**할 수 있다.   
수행 시간은 `O(NlogN)`으로 비교적 빠르다.   

  **priority_queue**를 이용한다.   
  


