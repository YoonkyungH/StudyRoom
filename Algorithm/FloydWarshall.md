> **다익스트라**
> : 한 지점에서 다른 특정 지점까지의 최단 경로를 구하는 알고리즘

# 플로이드워셜
모든 지점에서 다른 모든 지점까지의 최단 경로를 구하는 알고리즘

소스가 다익스트라에 비해 매우 짧아 구현이 쉬움.

**다익스트라**의 경우 단계마다 최단 거리를 가지는 노드를 하나씩 반복적으로 선택한 후 해당 노드를 거쳐가는 경로를 확인하며 최단 거리 테이블을 갱신하는 방식으로 동작한다.  
**플로이드 워셜**의 경우 이 또한 단계마다 거쳐 가는 노드를 기준으로 알고리즘을 수행한다. 하지만 매 단계마다 방문하지 않은 노드 중 최단 거리를 갖는 노드를 찾을 필요가 없다.

**다익스트라**는 한 지점에서 다른 지점까지의 최단 거리를 **1차원 리스트**에 저장한다.  
**플로이드 워셜**은 **2차원 테이블**에 최단 거리 정보를 저장한다. (모든 지점에서 다른 모든 지점까지의 최단 거리를 저장)

**다익스트라**는 **그리디** 알고리즘에 속한다고 볼 수 있다.  
**플로이드 워셜**은 **DP** 알고리즘에 속한다. 만약 노드의 개수가 N개라고 할 때, N번 만큼의 단계를 반복하며 점화식에 맞게 2차원 리스트를 갱신하기 때문에 DP라고 볼 수 있다.

## 플로이드 워셜 알고리즘
1. 그래프의 노드와 간선에 따라 최단 거리 테이블(2차원 배열) 갱신  
플로이드 워셜 알고리즘은 가장 먼저 자기 자신으로 부터의 거리를 2차원 배열에 0으로 초기화 시켜준다. 그리고 단방향 간선으로 갈 수 없는 노드는 무한으로, 나머지는 거리에 따라 초기화 시켜준다.

2. 1번 노드를 거쳐 가는 경우를 고려해 테이블을 갱신
3. 2번 노드를 거쳐 가는 경우를 ..
4. 이런식으로 마지막 노드까지 해당 노드를 거쳐가는 경우를 고려해 테이블을 갱신

```c++
// 플로이드워셜 뼈대코드
#include <iostream>
using namespace std;

#define INF 987654321

int n = 5;

int arr[5][5] = {
	{0, 2, 7, INF, 4},
	{INF, 0, INF, 3, 6},
	{INF, 3, 0, INF, INF},
	{-1, INF, -4, 0, INF},
	{INF, INF, INF, 5, 0},
};

  

void floydWarshall() {
	int d[5][5]; // 결과 그래프
	
	for(int i=0; i<n; i++) {
		for(int j=0; j<n; j++) {
			d[i][j] = arr[i][j];
		}
	}
	
	  
	
	for(int p=0; p<n; p++) { // p: 거쳐갈 정점
		for(int i=0; i<n; i++) {
			for(int j=0; j<n; j++) {
				if(d[i][p] + d[p][j] < d[i][j]) { // 거쳐 가는 것이 더 짧은 거리라면
					d[i][j] = d[i][p] + d[p][j]; // 갱신
				}
			}
		}
	}
	
	  
	
	// 출력
	// for(int i=0; i<n; i++) {
		// for(int j=0; j<n; j++) {
			// cout << d[i][j] << " ";
		// } cout << '\n';
	// }

}

  

int main() {
	floydWarshall();
  
	return 0;
}
```

---

[참고](https://velog.io/@kimdukbae/플로이드-워셜-알고리즘-Floyd-Warshall-Algorithm)
[참고](https://yjg-lab.tistory.com/186)
